# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_utils.ipynb.

# %% auto 0
__all__ = ['cosine_similarity', 'compute_ss_ds', 'freeze_env', 'transform_keypoints', 'annotate_img_with_kps']

# %% ../nbs/01_utils.ipynb 2
import numpy as np

# %% ../nbs/01_utils.ipynb 3
def cosine_similarity(X, Z):
    # Normalize the embeddings
    X = X / np.linalg.norm(X, axis=1, keepdims=True)
    Z = Z / np.linalg.norm(Z, axis=1, keepdims=True)

    # Compute the dot product between the normalized embeddings
    dot_product = np.dot(X, Z.T)

    # Return the cosine similarity between the embeddings
    return dot_product

# %% ../nbs/01_utils.ipynb 4
def compute_ss_ds(X, x_id, x_names=None, Z=None, z_id=None, z_names=None):
    """
    Compute cosine similarities between the cartesian product of two arrays X and Z and
    return same-source (ss) and different-source (ds) scores.
    If only the array X and x_id are provided, compute the cosine similarities between all pairwise
    combination in X. Also return the names of the files associated with each score, is x_names and z_names are provided.

    Inputs:
        X, Z: 2d numpy arrays with embeddings (1 per line)
        x_id, z_id: 1d numpy arrays with identity labels
        x_names, z_names: 1d numpy arrays with names of files associated with the embeddings

    Returns:
        scores: 1d numpy array with scores
        y: 1d numpy arrays with ss (1) and ds (0) labels to the scores array
        names: list of tuples with names of files associated with each score
    """
    assert X.ndim == 2
    assert X.shape[0] == len(x_id)
    ss_names = None
    ds_names = None
    if Z is None:  # compute scores of X vs X
        similarities = cosine_similarity(X, X)
        ss_mask = x_id[:, np.newaxis] == x_id
        upper_triangle_mask = np.triu(np.ones_like(similarities), k=1).astype(bool)
        ss = similarities[(ss_mask & upper_triangle_mask)]
        ds = similarities[(~ss_mask & upper_triangle_mask)]
        if x_names is not None:  # compute names of X vs X
            assert X.shape[0] == len(x_id) == len(x_names)
            ss_names = [
                (x_names[i], x_names[j])
                for i, j in np.argwhere(upper_triangle_mask)
                if x_id[i] == x_id[j]
            ]
            ds_names = [
                (x_names[i], x_names[j])
                for i, j in np.argwhere(upper_triangle_mask)
                if x_id[i] != x_id[j]
            ]
    if Z is not None:  # compute scores of X vs Z
        assert Z.ndim == 2
        assert Z.shape[0] == len(z_id)
        similarities = cosine_similarity(X, Z)
        ss_mask = x_id[:, np.newaxis] == z_id
        ss = similarities[ss_mask]
        ds = similarities[~ss_mask]
        if z_names is not None:  # compute names of X vs Z
            assert Z.shape[0] == len(z_id) == len(z_names)
            ss_names = [(x_names[i], z_names[j]) for i, j in np.argwhere(ss_mask)]
            ds_names = [(x_names[i], z_names[j]) for i, j in np.argwhere(~ss_mask)]

    scores = np.concatenate([ss, ds])
    y = np.concatenate([np.ones(len(ss)), np.zeros(len(ds))])
    names = (
        ss_names + ds_names if ss_names is not None and ds_names is not None else None
    )
    return scores, y, names

# %% ../nbs/01_utils.ipynb 10
def freeze_env():
    import sys
    import pkg_resources

    env = {}
    env.update({"Python version": f"{sys.version}"})

    installed_packages = [
        (d.project_name, d.version) for d in pkg_resources.working_set
    ]
    installed_packages.sort(
        key=lambda x: x[0].lower()
    )  # Sort alphabetically, case-insensitive

    for package, version in installed_packages:
        env.update({f"{package}": f"{version}"})
    return env

# %% ../nbs/01_utils.ipynb 12
def transform_keypoints(keypoints, M):
    """
    Transforms keypoints from the original image space to the aligned image space.

    Args:
        keypoints (numpy array): A 2D array of shape (5, 2) representing the original keypoints.
        M (numpy array): The 2x3 affine transformation matrix.

    Returns:
        numpy array: A 2D array of shape (5, 2) representing the transformed keypoints.
    """
    # Add a third dimension of ones to keypoints to allow affine transformation
    keypoints_homo = np.hstack([keypoints, np.ones((keypoints.shape[0], 1))])
    transformed_keypoints = (M @ keypoints_homo.T).T  # Apply affine transformation
    return transformed_keypoints

# %% ../nbs/01_utils.ipynb 13
def annotate_img_with_kps(
    bgr_img: np.ndarray, kps: np.ndarray, color: str = "red", radius: int = 2
) -> np.ndarray:
    """
    Annotate an image with keypoints.

    Parameters:
    bgr_img (numpy.ndarray): The input image in BGR format.
    kps (numpy.ndarray): A numpy array of shape (5, 2) containing the keypoints.
    color (str, optional): The color of the keypoints. Default is 'red'.
                        Options are 'red', 'blue', 'green', 'white', 'black'.
    radius (int, optional): The radius of the keypoints. Default is 2.

    Returns:
    numpy.ndarray: The image with keypoints annotated.
    """
    import cv2

    colors = {
        "red": (0, 0, 255),
        "blue": (255, 0, 0),
        "green": (0, 255, 0),
        "white": (255, 255, 255),
        "black": (0, 0, 0),
    }

    assert color in colors.keys()
    assert kps.shape == (5, 2)

    bgr_img_with_kps = bgr_img.copy()

    for x, y in kps:
        cv2.circle(
            bgr_img_with_kps,
            (int(x), int(y)),
            radius=radius,
            color=colors[color],
            thickness=-1,
        )

    return bgr_img_with_kps
